{% load static %}

<html>

    <link rel="stylesheet" href="{% static 'css/styles.css' %}">
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

<head>
</head>

<body>
    <div class = "page-preview">

        <div class = "head">
            <img class = "logo" src = "{% static 'media/logo.png' %}" width=300 height=140>
            <div class = "description">
                <label class = "description-label"> 
                    Texflow generates an entity-relation flowchart from an english text. 
                    The generated flowchart can illustrate and even summarize the text after the user enters a summarization percentage.
                    The user can modify the automatically generated flowchart to make it more satisfying.
                    Texflow can help the user identify relations between entities in lengthy texts.  
                </label>
            </div> 
        </div>

        <form action = "" method = "POST">

            <div class = "input-text">
                <label class = "label1"> Text </label> <br> <br>
                <textarea class = "input-text-area" id="input-text" 
                name="input-text" cols="60" rows= "15" type="text" required= "required";>
                Enter your text here.
                </textarea>
                <input type = "file" hidden class = "button1" id = "import-from-file" name = "Import From File">
                <label for = "import-from-file" class = "label-button1"> Import from a file </label> 
            </div>

            <div class = "features">
                
                <div class = "small-feature">
                    <label class = "feature-description"> 
                        For a brief graphical entity-relation representation of the text.
                    </label>
                    <input type = "submit" name = "quick-and-brief" class = "button2-small-feature" id = "quick-and-brief" value = "Quick & Brief">
                </div>
                
                <hr>

                <div class = "middle-feature">
                    <label class = "feature-description"> 
                        For a graphical entity-relation representation of the text with a specified 
                        percentage of the text to be represented in the flowchart, 
                        specify or drag the slider below to specify the desired percentage.
                    </label> <br>
                    <input id="amount" name= "amount" type="number" value="100" min="30" max="100" step = "1" class = "input-number" oninput="rangeInput.value=amount.value" />
                    <input  id="rangeInput" name= "rangeInput" type="range" value = "100" min="30" max="100" step = "1" class = "slider" oninput="amount.value=rangeInput.value" />
                    <input type ="submit" name = "generate-flowchart" class = "button2" id = "generate-flowchart" value = "Generate Flowchart">
                </div>
                
                <hr>

                <div class = "feature">
                    <label class = "feature-description"> 
                        If you're interested in relations between specific entities in the flowchart, 
                        specify these entities below (each on a line). If you already generated a flowchart, 
                        the textarea below contains suggested entities.
                    </label> <br>
                        <textarea id= "entities-list" name="entities-list" class= "large-textarea" type="text"> </textarea>
                        <textarea id = "hidden-input" name="hidden-input" style="display:none;" type="text"></textarea>
                        <input type = "submit" class = "button2-entities" name = "submit-entities" id = "submit-entities" value = "Submit Entities">
                </div>
                <hr> 

            </div>
        </form>


        <div class = "flowchart-area">
            <label class = "label1"> Flowchart </label> <br> <br>
            <label class = "description-label"> In the edge label '^' represents the source node and '_' represents the destination node, and they should be interpreted as the labels of the corresponding nodes.
                You may also hover on red nodes for more details. </label> <br> <br> 
            <div id = "flowchart" class = "flowchart"> </div>
            <button class = "button1" id = "save-as-image"> Save As Image </button>
        </div>
        
        <div class = "right-features">
                <!-- <button class = "button3" id="enable-physics"> Enable Physics</button>
                <button class = "button3" id="disable-physics"> Disable Physics</button> -->

                <!--
                    To highlight the path (representing the full relation) corresponding to 
                    an edge, select the edge and click on:
                -->
                <button class = "button3" 
                title = "To highlight the path (representing the full relation)
corresponding to an edge, select the edge before 
clicking on this button."
                id = "get-full-relation"> Highlight Full Path For Selected Edge </button>

                <!--
                    To highlight and print non-intersecting paths between 2 entities, select them and click on this button:
                -->
                <button class = "button3" 
                title = "To highlight and print non-intersecting paths 
between 2 entities, select them and click on this button."
                id = "get-paths"> Highlight Non-Intersecting Paths Between 2 Selected Nodes </button>

                <button class = "button3" id = "revert"> Revert To Original Colors </button>
                <button class = "button3" id = "merge-leaves"> Merge Leaves (Click again to go back to original) </button>
                <button class = "button3" id = "make-ER"> Put Edges in Grey Nodes (Click again to get the original flowchart)</button>
        </div>
        
    </div>
</body>
</html>

<style>
    .head {
        width: 100%;
        /*border: 3px solid rgb(255, 77, 100);*/
        padding:0;
    }
    .logo{
        border-collapse:collapse;
        position:relative;
        margin-left: 10%;
        margin-top: 4%;
        padding:0;
    }
    hr {
        background-color: #91acdf; 
        color:  #91acdf; 
        border-width: 0;
        height: 2px;
        position: relative;
    }
    .description {
        position:relative;
        margin-left: 10%;
        margin-right: 10%;
        margin-top: 1%;
        margin-bottom: 3%;
        padding:0;
    }
    .description-label{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 14px;
        color:#00297A;
        font-style: italic;
        line-height: 24px;
    }
    .input-text{
        position:relative;
        margin-left: 10%;
        margin-right: 10%;
        margin-top: 1%;
        margin-bottom: 3%;
        padding:0;
    }
    .label1{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 36px;
        color:#00297A;
        font-weight: bold;
        line-height: 50px;
        position:relative;
    }
    .input-text-area{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 14px;
        color: #3167cc;
        position:relative;
        resize:none; 
        border: 2px solid #91acdf; 
        padding: 0;
        margin:0;
        white-space: normal;
        width: 100%;
        height: 40%;
        line-height: 24px;
    }
    .button1{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 20px;
        font-weight: bold;
        background-color:#00297A;
        color:#91acdf; 
        border: 2px solid #91acdf; 
        width: 100%;
        height: 7%;
        cursor:pointer;
    }
    .label-button1{
        display: inline-block;
        width: 100%;
        height: 7%;
        cursor:pointer;
        text-align: center;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 20px;
        line-height: 48px;
        font-weight: bold;
        background-color:#00297A;
        color:#91acdf; 
        border: 2px solid #91acdf; 
    }
    .features{
        position:relative;
        margin-left: 10%;
        margin-right: 10%;
        margin-top: 1%;
        margin-bottom: 3%;
        padding:0;
    }
    .right-features{
        /*background-color: aqua;*/
        float: left;
        width: 20%;
        height: 100%;
        margin-top: 8.5%;
        margin-right: 10%;
    }
    .feature{
        height: 36%;
       /* border: 2px solid #91acdf; */
       margin-bottom: 3%;
       margin-top: 3%;
    }
    .small-feature{
        height: 6%;
       /* border: 2px solid #91acdf; */
       margin-bottom: 2.5%;
       margin-top: 1%;
    }
    .middle-feature{
        height: 12%;
       /* border: 2px solid #91acdf; */
       margin-bottom: 2.5%;
       margin-top: 1%;
    }
    .feature-description{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 16px;
        font-weight: bold;
        color:#00297A; 
        display: block;
        width: 70%;
        height: 20%;
        line-height: 24px;

    }
    .button2{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 20px;
        font-weight: bold;
        background-color:#00297A;
        color:#91acdf; 
        border: 2px solid #91acdf; 
        float:right;
        width: 20%;
        height: 50%;
        /*margin-right: 5%;*/
        margin-top: 2%;
        cursor:pointer;
    }
    .button2-entities:active{
        background-color:#2358c2;
        color:#91acdf; 
        border: 2px solid #91acdf; 
    }
    .button2-entities{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 20px;
        font-weight: bold;
        background-color:#00297A;
        color:#91acdf; 
        border: 2px solid #91acdf; 
        float:right;
        width: 20%;
        height: 16%;
        /*margin-right: 5%;*/
        margin-top: 13.5%;
        cursor:pointer;
    }
    .button2:active{
        background-color:#2358c2;
        color:#91acdf; 
        border: 2px solid #91acdf; 
    }
    .button2-small-feature{
        font-family: Arial, Helvetica, sans-serif;
        font-size: 20px;
        font-weight: bold;
        background-color:#00297A;
        color:#91acdf; 
        border: 2px solid #91acdf; 
        float:right;
        width: 20%;
        height: 100%;
        cursor:pointer;
    }
    .button2-small-feature:active{
        background-color:#2358c2;
        color:#91acdf; 
        border: 2px solid #91acdf; 
    }
    .button1:active{
        background-color:#2358c2;
        color:#91acdf; 
        border: 2px solid #91acdf; 
    }
    .button3:active{
        background-color:#2358c2;
        color:#91acdf; 
        border: 2px solid #91acdf; 
    }
    .button3:disabled{
        background-color:#00297a91;
        color:#91acdf; 
        border: 2px solid #4a7cda; 
    }
    .button3{
        float: top;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 16px;
        font-weight: bold;
        background-color:#00297A;
        color:#91acdf; 
        border: 2px solid #91acdf; 
        float:left;
        width: 80%;
        height: 10%;
        margin-bottom: 10%;
        margin-top: 5%;
        margin-left: 20%;
        cursor:pointer;
    }
    .flowchart-area{
        position:relative;
        float: left;
        width: 60%;
        margin-left: 10%;
        margin-right: 0%;
        margin-top: 1%;
        margin-bottom: 1%;
        padding:0;
        /*background-color: blueviolet;*/
    }
    .flowchart{
        position:relative;
        border:2px solid #91acdf; 
        width: 100%;
        height: 80%;
    }
    .large-textarea{
        resize: none;
        width: 60%;
        height: 70%;
        border: 2px solid #91acdf; 
        margin-top: 2%;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 14px;
        line-height: 24px;
        color:#3167cc;
    }
    .slider {
        float:left;
        width: 60%; 
        height: 25px;
        background: #91acdf;
        outline: none; 
        -webkit-transition: .2s; 
        transition: opacity .2s;
        margin-top: 2.5%;
        margin-bottom: 1%;
        margin-left: 0;
        margin-right: 3%;   
    }
    .input-number{
       /* float:right;*/
        width: 5%;
        font-size: 20px;
        font-weight: bold;
        color:#00297A; 
        margin-top: 2%;
    }
    div.vis-network div.vis-edit-mode button.vis-button.vis-edit.vis-edit-mode {
        color:rgb(13, 13, 112);
        background-color: white;
        border-color: white;
        text-align: center;
        font-size: 16pt;
        cursor: pointer
    }
    div.vis-network div.vis-edit-mode div.vis-label {
        font-size: 16pt;
        color: purple;
    }
    div.vis-network div.vis-manipulation button.vis-button.vis-add {
        color:rgb(13, 13, 112);
        background-color: white;
        border-color:rgb(13, 13, 112);
        text-align: center;
        font-size: 16pt;
        cursor: pointer
    }
    div.vis-network div.vis-manipulation div.vis-label {
        font-size: 16pt;
        color: black;
    }

    div.vis-network div.vis-manipulation div.vis-none {
        font-size: 16pt;
        color: black;  
    }
</style> 

<script> 
    function similarity_f(s1, s2) {
        var longer = s1;
        var shorter = s2;
        if (s1.length < s2.length) {
            longer = s2;
            shorter = s1;
        }
        var longerLength = longer.length;
        if (longerLength == 0) {
            return 1.0;
        }
        return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
    }
    function editDistance(s1, s2) {
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();

        var costs = new Array();
        for (var i = 0; i <= s1.length; i++) {
            var lastValue = i;
            for (var j = 0; j <= s2.length; j++) {
            if (i == 0)
                costs[j] = j;
            else {
                if (j > 0) {
                var newValue = costs[j - 1];
                if (s1.charAt(i - 1) != s2.charAt(j - 1))
                    newValue = Math.min(Math.min(newValue, lastValue),
                    costs[j]) + 1;
                costs[j - 1] = lastValue;
                lastValue = newValue;
                }
            }
            }
            if (i > 0)
            costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }
    document.getElementById('import-from-file').addEventListener('change', function () {
        var fr = new FileReader();
        fr.onload = function () {
            document.getElementById('input-text').textContent = this.result;
        };
        fr.readAsText(this.files[0]);
    });

    var transaction = JSON.parse("{{general|escapejs}}");
    if(transaction["time"] == 1 || transaction["time"] == 3){
        var words = JSON.parse("{{mainwords|escapejs}}");
        var wordlist = document.getElementById('entities-list');
        wordlist.innerHTML = "";
        for (var x in words) {
                if (x != "0") {
                    wordlist.innerHTML += (x + '\n');
                }
        }

        var hide = document.getElementById('hidden-input');
        hide.innerHTML = words["0"];

        var recoverInput = document.getElementById('input-text');
        recoverInput.innerHTML = words["0"];
    }
    let data3 = {}
    let in_nodes = [];
    let in_edges = [];
    let in_edges_labels = {};
    if(transaction["time"] <= 3){
        var data1 = JSON.parse("{{data1|escapejs}}"); 
        
        for (var x in data1) {
            if (x != "0") {
                var node = new Object();
                node.id = x;
                node.label = data1[x];
                in_nodes.push(node);
            }
        }

        data2 = JSON.parse("{{data2|escapejs}}"); 
        data3 = JSON.parse("{{data3|escapejs}}"); 

        for (var x in data2) {
            var edge = new Object();
            s = x.split('|');
            edge.from = s[0];
            edge.to = s[1];
            edge.relation = data2[x];
            in_edges_labels[s[0] + "|" + s[1] + "|" + data2[x] + "|"] = s[2];
            in_edges.push(edge);
        }
        var recoverInput = document.getElementById('input-text');
        recoverInput.innerHTML = data1["0"];
    }

    var graph = {};
    var relations = {};
    var nodes = [];
    paths = {};
    parentPath = {};
    
    if(transaction["time"] <= 2) {
        bulletpoints = JSON.parse("{{bullets|escapejs}}");
        mainlist = Object.keys(bulletpoints);
        
        for(var x  in mainlist){
            startvalue = in_nodes.length;
            var match = 0;
            for(var y in in_nodes){
                
                if(similarity_f(mainlist[x], in_nodes[y].label) > 0.4){
                    match = 1;
                }
                
            }
            if(match == 0){
                var node = new Object();
                node.id = startvalue;
                startvalue = startvalue + 1;
                node.label = mainlist[x];
                in_nodes.push(node);
            }
            

        }
        
        
    }
    
    function decreaseLabelWidth(maxWidth, l){
        
        var wordsList = l.split(" ");
        
        if (wordsList.length == 0){
            return l;
        }
        
        newLabel = wordsList[0];
        var charCount = newLabel.length;
        for (d_j = 1; d_j < wordsList.length; d_j++){

            if ( (charCount + wordsList[d_j].length) > maxWidth) {
                newLabel += ("\n" + wordsList[d_j]);
                charCount = wordsList[d_j].length;
            }
            else {
                newLabel += (" " + wordsList[d_j]);
                charCount += 1;
                charCount += wordsList[d_j].length;
            }
        }
        
        return newLabel;
    }
    redNodes = {};
    for (i = 0; i < in_nodes.length; i++){
        var node = new Object();
        node.id = in_nodes[i].id;
        node.label = in_nodes[i].label;
        if(transaction["time"] <= 2){
            var main_nodes = Object.keys(bulletpoints);

            for(j = 0; j<main_nodes.length; j++) {
                if(similarity_f(in_nodes[i].label, main_nodes[j]) > 0.4) {
                    //alert(in_nodes[i].label + main_nodes[j]);
                    var much = bulletpoints[main_nodes[j]].length;
                    var future_title = "";
                    var counter = 0;

                    for(k = 0; k < much; k++){
                        var line = "";
                        line = decreaseLabelWidth(100, bulletpoints[main_nodes[j]][k]);
                        //line = bulletpoints[main_nodes[j]][k];
                        future_title += ("-" + line + "\n");
                        counter = counter + 1;
                    } 
                    if(counter > 0){
                        node.title = future_title;
                        node.color = {background: "#FF0000"};
                        redNodes[node.id] = "";
                    }
                }
            }
                

        }   
    
        nodes.push(node);
    }
    
    nodes = new vis.DataSet(nodes);


    var edges = [];
    for (i = 0; i < in_edges.length; i++){
        
        relKey = in_edges[i].from + "_" +  in_edges[i].to;  
        relations[relKey] = in_edges[i].relation;
        
        var edge = new Object();
        edge.from = in_edges[i].from;
        edge.to = in_edges[i].to;
        edge.label = in_edges[i].relation;

        edges.push(edge);

        if (! (in_edges[i].from in graph) ) {
            graph[(in_edges[i].from)] = [];
        }
        
        graph[in_edges[i].from].push(in_edges[i].to);

        if (! (in_edges[i].to in graph)) {
            graph[in_edges[i].to] = [];
        }
        graph[in_edges[i].to].push(in_edges[i].from); 
    }
    
    edges = new vis.DataSet(edges);
    
    var container = document.getElementById('flowchart');

    var data = {
        nodes: nodes,
        edges: edges
    };

    var options = 
    {
        width: '100%',
        length: '100%',
        navigation: true,
        configurePhysics: true,
        manipulation: {
            addNode: function(nodeData, callback){
                var inputNodeLabel = prompt("Please enter the label of the node");
                nodeData.label = inputNodeLabel;
                callback(nodeData);
            },
            addEdge: function(edgeData,callback) {
            
                var inputEdgeLabel = prompt("Please enter the label of the edge");
                edgeData.label = inputEdgeLabel;
                
                if (edgeData.from === edgeData.to) {
                    var r = confirm("Are you sure you want to connect the node to itself?");
                    if (r === true) {
                        callback(edgeData);
                        nodeF = edgeData.from;
                        nodeT = edgeData.to;

                        if (nodeF < nodeT) {
                            var temp = nodeF;
                            nodeF = nodeT;
                            nodeT = temp;
                        }
                        if ((nodeF + "_" + nodeT) in dict) {
                            dict[nodeF + "_" + nodeT].push(edgeData.id);
                        }
                        else {
                            dict[nodeF + "_" + nodeT] = [edgeData.id];
                        } 
                        
                        element = nodeF + "_" + nodeT;
                        if (dict[element].length > 1) {
                            for (i = 1 ; i <= dict[element].length; i++){
                                var angle = (i*1.0)/dict[element].length;
                                //network.body.edges[dict[element][i-1]].options.smooth.roundness = angle;
                            }
                        }
                    }
                }
                else {
                    callback(edgeData);
                    nodeF = edgeData.from;
                    nodeT = edgeData.to;

                    if (nodeF < nodeT) {
                        var temp = nodeF;
                        nodeF = nodeT;
                        nodeT = temp;
                    }
                    if ((nodeF + "_" + nodeT) in dict) {
                        dict[nodeF + "_" + nodeT].push(edgeData.id);
                    }
                    else {
                        dict[nodeF + "_" + nodeT] = [edgeData.id];
                    } 
                    
                    element = nodeF + "_" + nodeT;
                    if (dict[element].length > 1) {
                        for (i = 1 ; i <= dict[element].length; i++){
                            var angle = (i*1.0)/dict[element].length;
                            //network.body.edges[dict[element][i-1]].options.smooth.roundness = angle;
                        }
                    }
                }
            },

            editNode: function (data, callback) {
                var newNodeLabel = prompt("Please enter the new label of the selected node");
                data.label = newNodeLabel;
                callback(data);
            },

            editEdge: function (data, callback) {
                var newEdgeLabel = prompt("Please enter the new label of the selected edge");
                data.label = newEdgeLabel;
                callback(data);
            }
        },
        interaction: {multiselect: true},
        layout: {
            /*
            randomSeed: undefined,
            improvedLayout:true,
            clusterThreshold: 150,
            hierarchical: {
            enabled:false,
            levelSeparation: 200,
            nodeSpacing: 100,
            treeSpacing: 200,
            blockShifting: true,
            edgeMinimization: true,
            parentCentralization: true,
            direction: 'UD',        // UD, DU, LR, RL
            sortMethod: 'hubsize',  // hubsize, directed
            shakeTowards: 'leaves'  // roots, leaves
            },
            */
            hierarchical: {
                
                levelSeparation: 200,
                nodeSpacing: 50,
                treeSpacing: 100,
                blockShifting: true,
                edgeMinimization: true,
                direction: "UD",
                sortMethod: "hubsize",
            },
        },
        physics: {
            enabled: true,
            hierarchicalRepulsion: {
                avoidOverlap: 1,
            },
        },
    
                
        edges: {
            width: 1.5,
            length: 300,
            style: 'line',
            smoothCurves: false,
            color: {
                color: '#6ebfff', 
                highlight: '#0061fc'
            },
            font: {
                size: 12,
                color: '#00297A',
                align: "horizontal",
            },
            arrows:{
                to: {
                    enabled: true,
                    scaleFactor: 0.5,
                    type:"arrow"
                },
            },
            smooth: {
                type: "discrete",
            }
        },
        nodes: {
            shape: 'box',
            color: {
                background: '#c4e5ff',
                border: '#6ebfff',
                highlight: {
                    border: '#0061fc',
                    background: '#80c7ff', //'#ffadbe',
                }
            },
            borderWidth: 2, 
            font: {
                size: 16,
                multi: true,
                align: 'center',
                color: '#00297A',
            },
            margin: { top: 10, right: 10, bottom: 10, left: 10 },
            heightConstraint: { minimum: 40 },
            widthConstraint: { minimum: 60 }
        },
    };

    var network = new vis.Network(container, data, options);
    network.fit();
    
    setTimeout(()=>{
        network.setOptions({
            layout:{
                hierarchical: false
            },
        });
    },1000);
    
    setTimeout(()=>{
        network.setOptions( {physics: false});
    },1000);
    
    network.fit();
    dict = {}
    for (edge in network.body.edges){
        
        nodeFrom = network.body.edges[edge].options.from;
        nodeTo = network.body.edges[edge].options.to;
        
        nodeF = nodeFrom;
        nodeT = nodeTo;
        
        if (nodeF < nodeT) {
            var temp = nodeF;
            nodeF = nodeT;
            nodeT = temp;
        }
        if ((nodeF + "_" + nodeT) in dict) {
            dict[nodeF + "_" + nodeT].push(edge);
            /*
            network.body.edges[edge].options.smooth.type = "dynamic";
            network.body.edges[dict[nodeF + "_" + nodeT]].options.smooth.type = "dynamic";
            */
        }
        else {
            dict[nodeF + "_" + nodeT] = [edge];
            /*
            network.body.edges[edge].options.smooth.type = "discrete";
            */
        } 

        label1 = network.body.edges[edge].options.label;

        originalEdgeLabel = in_edges_labels[nodeFrom + "|" + nodeTo + "|" + label1 + "|"];

        value = nodeFrom + "|" + nodeTo + "|" + originalEdgeLabel + "|";
        parentPath[edge] = data3[value];

        if (data3[value] in paths){
            paths[data3[value]].push(edge);
        }
        else {
            paths[data3[value]] = [edge];
        }

    }

    for (element in dict) {
        if (dict[element].length > 1) {
            for (i = 1 ; i <= dict[element].length; i++){
                var angle = (i*1.0)/dict[element].length;
                //network.body.edges[dict[element][i-1]].options.smooth.roundness = angle;
            }
        }
    }

    function isLeaf(nodeId){
        return graph[nodeId].length == 1;
    }

    function joinLeaves(){
        network.setData(data);

        parent = {}
        for(i=0; i < in_nodes.length; i++){
            if (isLeaf(in_nodes[i].id)) {
                parent[in_nodes[i].id] = (graph[in_nodes[i].id])[0];
            }
            else {
                parent[in_nodes[i].id] = in_nodes[i].id;
            } 
        }
        
        bullets = {}
        for (i = 0; i < in_nodes.length; i++) {
            if (!(parent[in_nodes[i].id] in bullets)){
                bullets[parent[in_nodes[i].id]] = "";
            }

            if ( parent[in_nodes[i].id] !== in_nodes[i].id){
                k1 = parent[in_nodes[i].id] + "_" + in_nodes[i].id;
                k2 = in_nodes[i].id + "_" + parent[in_nodes[i].id];
                
                line = ""
                if (k1 in relations){
                    line += ( "(<i>" + parent[in_nodes[i].id]+ "</i>) " +  relations[k1] +  " (<i>" + in_nodes[i].id) + "</i>)\n";
                }

                if (k2 in relations){
                    line += ( "(<i>" + in_nodes[i].id + "</i>) " + relations[k2]  + " (<i>" + parent[in_nodes[i].id]) + "</i>)\n";
                }
                
                bullets[parent[in_nodes[i].id]] = bullets[parent[in_nodes[i].id]] + line;
                
            }
            
        }
        for(i = 0; i < in_nodes.length; i++) {

            clusterOptionsByData = {
                joinCondition: function(childOptions){
                    return parent[childOptions.id] === in_nodes[i].id; 
                },
                
                clusterNodeProperties: {
                    id: "Cluster:\n"+ in_nodes[i].label,
                    borderWidth: 2,
                    shape: "box",
                    font: {multi: "html", size: 14},
                    label: 
                        "<b>" + parent[in_nodes[i].id] + "</b>" + "\n\n" + bullets[parent[in_nodes[i].id]],
                    font: { color: "#eb2f87" },

                },
            }
            network.cluster(clusterOptionsByData);

        }
    }

    let mergeLeavesButton = document.getElementById("merge-leaves");
    let merged = false;

    mergeLeavesButton.onclick = function() {
        
        if (merged == true){
            for (nodeId in network.body.nodes) {
                if (network.isCluster(nodeId) === true) {
                    network.openCluster(nodeId);
                }
            }
            network.setOptions( {physics: true});
            network.setOptions( {layout:{hierarchical: true}});
            network.fit();
            
            setTimeout(()=>{
                network.setOptions({
                    layout:{
                        hierarchical: false
                    },
                });
            },1000);
        
            setTimeout(()=>{
                network.setOptions( {physics: false});
            },1000);
            network.fit();
            merged = false;

            document.getElementById("get-paths").disabled = false; 
            document.getElementById("get-full-relation").disabled = false; 
            document.getElementById("make-ER").disabled = false; 
            document.getElementById("revert").disabled = false; 

            return;
        }
        merged = true;
        
        document.getElementById("get-paths").disabled = true; 
        document.getElementById("get-full-relation").disabled = true; 
        document.getElementById("make-ER").disabled = true; 
        document.getElementById("revert").disabled = true; 

        leavesCount = 0
        for(i=0; i < in_nodes.length; i++){
            if (isLeaf(in_nodes[i].id)){
                leavesCount++;
            }
        }
        joinLeaves();

        network.setOptions( {physics: true});
        network.setOptions( {layout:{hierarchical: true}});
        network.fit();
        
        setTimeout(()=>{
            network.setOptions({
                layout:{
                    hierarchical: false
                },
            });
        },1000);
    
        setTimeout(()=>{
            network.setOptions( {physics: false});
        },1000);
        network.fit();
    }

    selectedEdges = {};
    selectedEdgesCount = 0;
    selectedNodes = {};
    selectedNodesCount = 0;
    
    network.on("selectEdge", function(param){
        selectedEdges = {};
        selectedEdgesCount = 0;
        for (i = 0; i < param.edges.length; i++) {
            selectedEdges[param.edges[i]] = "";
            selectedEdgesCount += 1;
        }
    });

    network.on("deselectEdge", function(param){
        for (i = 0; i < param.previousSelection.edges.length; i++) {
            previouslySelectedEdge = param.previousSelection.edges[i].id;
            if (! (previouslySelectedEdge in param.edges)  && (previouslySelectedEdge in selectedEdges)) {
                delete selectedEdges[previouslySelectedEdge];
                selectedEdgesCount -= 1;
            }
        }
    });

    network.on("selectNode", function(param){

        if (param.nodes.length === 1 && network.isCluster(param.nodes[0]) === true) {
            //network.openCluster(param.nodes[0]);
        }
        else {
            selectedNodes = {};
            selectedNodesCount = 0;
            for (i = 0; i < param.nodes.length; i++) {
                selectedNodes[param.nodes[i]] = "";
                selectedNodesCount += 1;
            }
        }
    });

    network.on("deselectNode", function(param){
        for (i = 0; i < param.previousSelection.nodes.length; i++) {
            
            previouslySelectedNode = param.previousSelection.nodes[i].id;

            if ( !(param.nodes.includes(previouslySelectedNode)) && (previouslySelectedNode in selectedNodes)) {
                delete selectedNodes[previouslySelectedNode];
                selectedNodesCount -= 1;
            }

        }
    });
    /*
    let disablePhysicsButton = document.getElementById("disable-physics");
    disablePhysicsButton.onclick = function() {
        network.setOptions( { physics: false } );
        return;
    }

    let enablePhysicsButton = document.getElementById("enable-physics");
    enablePhysicsButton.onclick = function() {
        network.setOptions( { physics: true } );
        return;
    }*/
    
    changedNodes = [];
    changedEdges = [];

    let getFullRealtionButton = document.getElementById("get-full-relation");
    getFullRealtionButton.onclick = function(){
        
        if(selectedEdgesCount == 0) {
            alert("Please select an edge before you click on this button.")
        }
        else if (selectedEdgesCount == 1){
            edgeId = ""
            for (edge in selectedEdges){
                edgeId = edge;
            } 
            parPath = parentPath[edgeId];
            
            nodeFromSel = network.body.edges[edgeId].options.from.toString();
            nodeToSel = network.body.edges[edgeId].options.to.toString();

            if (network.isCluster(nodeFromSel) || network.isCluster(nodeToSel)){
                return;
            }
            newColor = '#c400b4'; //'#ff667d'; //'#eb69ff'
            newFontColor = '#8c0081';
            newBackColor = '#ffc7fb';
            if(network.body.edges[edgeId].options.color.color === newColor) {
                return;
            } 
            
            edges.update({id: edgeId, color:{color:newColor}, font: { color: newFontColor }});
            changedEdges.push(edgeId);

            nodes.update({id: nodeFromSel, color:{border:newColor, background: newBackColor}, font: { color: newFontColor  }});
            changedNodes.push(nodeFromSel);

            nodes.update({id: nodeToSel, color:{border:newColor, background: newBackColor}, font: {color: newFontColor  }});
            changedNodes.push(nodeToSel);

            for (i = 0 ; i < paths[parPath].length; i++) {
                edge = (paths[parPath])[i];

                nodeFrom = network.body.edges[edge].options.from.toString();
                nodeTo = network.body.edges[edge].options.to.toString();

                if (nodeFromSel.localeCompare(nodeFrom) === 0 && nodeToSel.localeCompare(nodeTo) === 0){
                    continue;
                } 

                edges.update({id: edge, color:{color:newColor}, font: { color: newFontColor}});
                changedEdges.push(edge);

                nodes.update({id: nodeFrom, color:{border:newColor, background: newBackColor}, font: { color: newFontColor }});
                changedNodes.push(nodeFrom);

                nodes.update({id: nodeTo, color:{border:newColor, background: newBackColor}, font: { color: newFontColor}});
                changedNodes.push(nodeTo);
            }
        }
        else {
            alert("Please select exactly 1 edge before you click on this button.")
        }
    }

    let getRelationsButton = document.getElementById("get-paths");
    getRelationsButton.onclick = function(){
        if (selectedNodesCount != 2) {
            alert("Please select exactly 2 nodes. \nMake sure that you use a long click or press Ctrl before you select the second node.");
            return;
        }
        selectedNodesList = []
        for (node in selectedNodes){
            selectedNodesList.push(node);
        }
        findNonIntersectingPaths(selectedNodesList[0], selectedNodesList[1]);
    }

    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    
    findNonIntersectingPaths = function(node1, node2){

        newColor = '#c400b4';
        newFontColor = '#8c0081';
        newBackColor = '#ffc7fb';
        nodes.update({id: node1, color:{border: newColor, background: newBackColor}, font: { color: newFontColor, bold:true }});
        nodes.update({id: node2, color:{border: newColor,  background: newBackColor}, font: { color: newFontColor, bold:true}});
        
        changedNodes.push(node1);
        changedNodes.push(node2);

        path = []; 
        parentNode = {};
        takenEdges = {};
        count = 0;
        while(true) {
            count += 1;

            newColor = getRandomColor();
            
            let bfsQueue = []
            startOfQueue = 0;
            bfsQueue.push(node1);
            parentNode[node1] = ["-1", "-1"];
            
            while(startOfQueue != bfsQueue.length){
                
                nodeToProcess = bfsQueue[startOfQueue];
                connectedEdges = network.getConnectedEdges(nodeToProcess);
                
                for (i = 0; i < connectedEdges.length; i++) {
                    if (connectedEdges[i] in takenEdges){
                        continue;
                    }
                    edgeId = connectedEdges[i];
                    nodeFrom = network.body.edges[edgeId].options.from.toString();
                    nodeTo = network.body.edges[edgeId].options.to.toString();
                    
                    childNode = nodeFrom; 
                    if (nodeFrom.localeCompare(nodeToProcess) == 0){ // equal
                        childNode = nodeTo;
                    }

                    if (!(childNode in parentNode)){ // check if childNode is a newly discovered node
                        parentNode[childNode] = [nodeToProcess, edgeId];
                        bfsQueue.push(childNode); // add to queue
                        if (childNode.localeCompare(node2) == 0){ // if we reach node2 we break
                            break;
                        }
                    }
                }
                startOfQueue += 1; // pop element
            }

            reached = (node2 in parentNode);
            if (!reached) {
                break;
            }

            current = node2;
            pathToPrint = [];
            pathNodes = {};

            while (current.localeCompare(node1) != 0){
 
                nodeFrom = network.body.edges[parentNode[current][1]].options.from.toString();
                nodeTo = network.body.edges[parentNode[current][1]].options.to.toString();
                edgeLabel = network.body.edges[parentNode[current][1]].options.label.toString();
            
                pathNodes[nodeTo] = "0";
                pathNodes[nodeFrom] = "0";
                takenEdges[parentNode[current][1]] = "0";

                edges.update({id: parentNode[current][1], color:{color: newColor}, font: { color: newColor}});
                changedEdges.push(parentNode[current][1]);

                if (nodeFrom.localeCompare(node1) != 0 && nodeFrom.localeCompare(node2) != 0) {
                    nodes.update({id: nodeFrom, color:{border:newColor, background: '#c4e5ff'}, font: { color: newColor }});
                    changedNodes.push(nodeFrom);
                }
                if (nodeTo.localeCompare(node1) != 0 && nodeTo.localeCompare(node2) != 0) {
                    nodes.update({id: nodeTo, color:{border:newColor, background: '#c4e5ff'}, font: { color: newColor}});
                    changedNodes.push(nodeTo);
                }
            
                pathToPrint.push(nodeFrom + " " + edgeLabel + " " + nodeTo + "\n");
                current = parentNode[current][0];
            }

            for (node in parentNode) {
                if( !(node in pathNodes) || node == node2){
                    delete parentNode[node];
                }
            }
            
        }

        return;
    }

    let revertButton = document.getElementById("revert");
    revertButton.onclick = function(){
        return revertToOriginalColors(changedNodes, changedEdges);
    }
    revertToOriginalColors = function(nodesList, edgesList){
        originalColor = '#6ebfff';
        originalFontColor = '#00297A';
        originalBackColor = '#c4e5ff';
                
        for (i = 0; i < nodesList.length; i++){
            if (nodesList[i] in redNodes){
                originalBackColor = '#FF0000';
            }
            else {
                originalBackColor = '#c4e5ff';
            }
            nodes.update({id: nodesList[i], color:{border:originalColor, background: originalBackColor}, font: { color: originalFontColor, bold: false}});
        }

        for (i = 0; i < edgesList.length; i++){
            edges.update({id: edgesList[i], color:{color:originalColor}, font: { color: originalFontColor}});
        }
        changedNodes = [];
        changedEdges = [];
    }

    let saveAsImageButton = document.getElementById("save-as-image");
    saveAsImageButton.onclick = function() {
        var flowchartCanvas = document.getElementsByTagName('canvas')[0];
        flowchartCanvas.toBlob(function(blob) {
            var a = document.createElement("a");
            document.body.appendChild(a);
            a.download = "flowchart.png";
            a.href = window.URL.createObjectURL(blob);
            a.click();
            URL.revokeObjectURL(a.href);
        });
        return;
    }

    edgesInGreyNodes = false;
    
    let makeERButton = document.getElementById("make-ER");
    makeERButton.onclick = function(){
        
        if (! edgesInGreyNodes) {
            putEdgesInGreyNodes()
            document.getElementById("get-paths").disabled = true; 
            document.getElementById("get-full-relation").disabled = true; 
            document.getElementById("merge-leaves").disabled = true;
            document.getElementById("revert").disabled = true;
        }
        else {
            removeGreyNodes()
            document.getElementById("get-paths").disabled = false; 
            document.getElementById("get-full-relation").disabled = false; 
            document.getElementById("merge-leaves").disabled = false;
            document.getElementById("revert").disabled = false;
        }
        edgesInGreyNodes = ! edgesInGreyNodes; 
    }

    edgesToAdd = [];
    edgesToRemove = [];
    nodesToAdd = [];

    function putEdgesInGreyNodes() {
        for (edgeId in network.body.edges){
            edgeLabel = network.body.edges[edgeId].options.label;
            if (typeof edgeLabel === 'undefined' || edgeLabel.localeCompare("") == 0 || edgeLabel.localeCompare(" ") == 0 ){
            }
            else {
                nodeFrom = network.body.edges[edgeId].options.from;
                nodeTo = network.body.edges[edgeId].options.to;

                newNodeId = nodeFrom + "|" + nodeTo + "|" + edgeLabel + "|";
                nodesToAdd.push({id: newNodeId, 
                label: edgeLabel, 
                shape: 'ellipse', 
                color:{background:'#e8e8e8', border:'#e8e8e8'}, 
                font:{color:'grey'}});

                edgesToAdd.push({from: nodeFrom, to: newNodeId, smooth:{type:'discrete'}});
                edgesToAdd.push({from: newNodeId, to: nodeTo, smooth:{type:'discrete'}});
                edgesToRemove.push({id: edgeId, from: nodeFrom, to: nodeTo, label: edgeLabel, smooth:{type:'discrete'}});
            }
        }

        for (i = 0; i < nodesToAdd.length; i++){
            nodes.add(nodesToAdd[i]);
        }
        
        for (i=0; i < edgesToRemove.length; i++){
            edges.remove(edgesToRemove[i]);  
        }
        
        for (i=0; i < edgesToAdd.length; i++){
            edges.add(edgesToAdd[i]);  
        }

        
        network.setOptions( {physics: true});
        network.setOptions( {layout:{hierarchical: true}});
        network.fit();
        
        setTimeout(()=>{
            network.setOptions({
                layout:{
                    hierarchical: false
                },
            });
        },1000);
    
        setTimeout(()=>{
            network.setOptions( {physics: false});
        },1000);
        network.fit();
    }

    function removeGreyNodes() {
        
        for (i=0; i < edgesToRemove.length; i++){
            edges.add(edgesToRemove[i]);  
        }
        
        for (i=0; i < edgesToAdd.length; i++){
            edges.remove(edgesToAdd[i]);  
        }

        for (i = 0; i < nodesToAdd.length; i++){
            nodes.remove(nodesToAdd[i]);
        }

        edgesToAdd = [];
        edgesToRemove = [];
        nodesToAdd = [];

        network.setOptions( {physics: true});
        network.setOptions( {layout:{hierarchical: true}});
        network.fit();
        
        setTimeout(()=>{
            network.setOptions({
                layout:{
                    hierarchical: false
                },
            });
        },1000);
    
        setTimeout(()=>{
            network.setOptions( {physics: false});
        },1000);
        network.fit();

    } 
    
</script>
